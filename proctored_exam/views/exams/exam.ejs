<!-- views/exams/exam.ejs -->
<%- include('../layouts/exam-layout', { title: title }) %>


<div id="exam-container" class="exam-container">
  <!-- Header -->
  <header class="exam-header">
    <div class="container mx-auto px-4 flex justify-between items-center">
      <div class="exam-info">
        <h1 id="exam-title" class="exam-title"><%= exam.name %></h1>
        <div class="exam-certification"><%= certification.name %></div>
      </div>
      <div id="timer-container" class="timer-container">
        <div id="timer" class="timer">
          <i class="far fa-clock mr-2"></i>
          <span id="timer-display">00:00:00</span>
        </div>
      </div>
    </div>
  </header>

  <div class="container mx-auto px-4 py-6">
    <div class="flex flex-col md:flex-row">
      <!-- Main Exam Area -->
      <main class="exam-main flex-grow">
        <!-- Progress Bar -->
        <div class="progress-container mb-6">
          <div class="flex justify-between items-center mb-2">
            <div id="question-progress" class="question-progress">
              Question <span id="current-question-num">1</span> of <span id="total-questions"><%= questions.length %></span>
            </div>
            <div class="flex items-center">
              <button id="review-toggle" class="review-toggle">
                <i class="fas fa-list mr-2"></i> Review All
              </button>
            </div>
          </div>
          <div class="progress-bar">
            <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
          </div>
        </div>

        <!-- Question Content -->
        <div id="question-container" class="question-container">
          <!-- Will be populated dynamically -->
        </div>

        <!-- Navigation Controls -->
        <div id="navigation-controls" class="navigation-controls">
          <button id="prev-button" class="nav-button prev-button" disabled>
            <i class="fas fa-chevron-left mr-2"></i> Previous
          </button>
          <button id="flag-button" class="flag-button" data-flagged="false">
            <i class="far fa-flag mr-2"></i> <span id="flag-text">Flag for Review</span>
          </button>
          <button id="next-button" class="nav-button next-button">
            Next <i class="fas fa-chevron-right ml-2"></i>
          </button>
          <button id="submit-button" class="submit-button hidden">
            Submit Exam
          </button>
        </div>
      </main>

      <!-- Right Sidebar (Question Navigator) -->
      <aside id="question-navigator" class="question-navigator">
        <div class="navigator-header">
          <h2 class="navigator-title">Question Navigator</h2>
          <button id="close-navigator" class="close-navigator">
            <i class="fas fa-times"></i>
          </button>
        </div>
        
        <div class="navigator-filters">
          <button class="filter-button active" data-filter="all">All (<span id="count-all">0</span>)</button>
          <button class="filter-button" data-filter="answered">Answered (<span id="count-answered">0</span>)</button>
          <button class="filter-button" data-filter="flagged">Flagged (<span id="count-flagged">0</span>)</button>
          <button class="filter-button" data-filter="unanswered">Unanswered (<span id="count-unanswered">0</span>)</button>
        </div>
        
        <div id="question-grid" class="question-grid">
          <!-- Will be populated dynamically -->
        </div>
        
        <div class="navigator-footer">
          <button id="navigator-submit" class="navigator-submit">Submit Exam</button>
        </div>
      </aside>

      <!-- Proctor Webcam (if enabled) -->
      <% if (proctorEnabled) { %>
        <div id="proctor-webcam-container" class="proctor-webcam-container">
          <video id="proctor-webcam" autoplay playsinline muted></video>
          <div class="proctor-status">
            <div id="proctor-status-indicator" class="status-indicator status-active"></div>
            <div id="proctor-status-text" class="status-text">Proctoring Active</div>
          </div>
        </div>
      <% } %>
    </div>
  </div>
</div>

<!-- Exam Modals -->

<!-- Submit Confirmation Modal -->
<div id="submit-modal" class="modal hidden">
  <div class="modal-overlay"></div>
  <div class="modal-container max-w-md">
    <div class="modal-header">
      <h2>Submit Exam</h2>
      <button id="close-submit-modal" class="modal-close">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <p>Are you sure you want to submit your exam? Once submitted, you will not be able to return to the exam.</p>
      
      <div id="unanswered-warning" class="mt-4 hidden">
        <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4">
          <div class="flex">
            <div class="flex-shrink-0">
              <i class="fas fa-exclamation-triangle text-yellow-400"></i>
            </div>
            <div class="ml-3">
              <p class="text-sm text-yellow-700">
                <span id="unanswered-count">0</span> questions remain unanswered.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button id="confirm-submit" class="btn btn-danger">Submit Exam</button>
      <button id="cancel-submit" class="btn btn-outline">Continue Exam</button>
    </div>
  </div>
</div>

<!-- Time Warning Modal -->
<div id="time-warning-modal" class="modal hidden">
  <div class="modal-overlay"></div>
  <div class="modal-container max-w-md">
    <div class="modal-header">
      <h2>Time Running Out</h2>
      <button id="close-time-warning-modal" class="modal-close">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <div class="text-center mb-4">
        <i class="far fa-clock text-4xl text-yellow-500"></i>
      </div>
      <p class="text-center">You have <span id="time-remaining-warning">5 minutes</span> remaining in this exam.</p>
    </div>
    <div class="modal-footer justify-center">
      <button id="acknowledge-time-warning" class="btn btn-primary">Continue Exam</button>
    </div>
  </div>
</div>

<!-- Proctor Warning Modal -->
<div id="proctor-warning-modal" class="modal hidden">
  <div class="modal-overlay"></div>
  <div class="modal-container max-w-md">
    <div class="modal-header bg-yellow-50">
      <h2 class="text-yellow-800">Proctor Warning</h2>
      <button id="close-proctor-warning" class="modal-close">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <div class="text-center mb-4">
        <i class="fas fa-exclamation-triangle text-4xl text-yellow-500"></i>
      </div>
      <p id="proctor-warning-message" class="text-center">
        Your face must remain visible during the exam.
      </p>
    </div>
    <div class="modal-footer justify-center">
      <button id="acknowledge-proctor-warning" class="btn btn-warning">I Understand</button>
    </div>
  </div>
</div>

<!-- Webcam Permission Modal -->
<div id="webcam-permission-modal" class="modal hidden">
  <div class="modal-overlay"></div>
  <div class="modal-container max-w-md">
    <div class="modal-header">
      <h2>Camera Access Required</h2>
    </div>
    <div class="modal-body">
      <div class="text-center mb-4">
        <i class="fas fa-video text-4xl text-blue-500"></i>
      </div>
      <p class="text-center">
        This exam is proctored and requires webcam access. Please allow camera access to continue.
      </p>
      <div class="bg-blue-50 border-l-4 border-blue-400 p-4 mt-4">
        <div class="flex">
          <div class="flex-shrink-0">
            <i class="fas fa-info-circle text-blue-400"></i>
          </div>
          <div class="ml-3">
            <p class="text-sm text-blue-700">
              Your webcam feed is only used for proctoring during this exam session and is not recorded.
            </p>
          </div>
        </div>
      </div>
    </div>
    <div class="modal-footer justify-center">
      <button id="retry-webcam" class="btn btn-primary">Allow Camera Access</button>
    </div>
  </div>
</div>

<!-- Data Storage -->
<script>
    // Initialize exam data
    let examData = {
      id: '<%= attempt._id %>',
      timeLimit: <%= (exam.timeLimit || certification.timeLimit) %> * 60, // Convert minutes to seconds
      questions: <%- JSON.stringify(questions) %>,
      proctorEnabled: <%= proctorEnabled %>,
      answers: {},
      timeSpent: {},
      flagged: [],
      currentQuestionIndex: 0,
      startTime: Date.now(),
      endTime: null,
      proctorEvents: []
    };
  
    // Initialize with existing data if available
    <% if (typeof userAnswers !== 'undefined' && userAnswers) { %>
      examData.answers = <%- JSON.stringify(userAnswers) %>;
    <% } %>
  
    <% if (attempt && attempt.questions) { %>
      // Initialize timeSpent from attempt data
      examData.timeSpent = {};
      <% attempt.questions.forEach(q => { %>
        <% if (q.timeSpent) { %>
          examData.timeSpent['<%= q.questionId %>'] = <%= q.timeSpent %>;
        <% } %>
      <% }); %>
      
      // Initialize flagged questions
      examData.flagged = [];
      <% attempt.questions.forEach((q, idx) => { %>
        <% if (q.flagged) { %>
          examData.flagged.push(<%= idx %>);
        <% } %>
      <% }); %>
    <% } %>
  </script>


<!-- Main Exam Logic -->
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // DOM Elements
    const timerDisplay = document.getElementById('timer-display');
    const questionContainer = document.getElementById('question-container');
    const prevButton = document.getElementById('prev-button');
    const nextButton = document.getElementById('next-button');
    const submitButton = document.getElementById('submit-button');
    const flagButton = document.getElementById('flag-button');
    const flagText = document.getElementById('flag-text');
    const currentQuestionNum = document.getElementById('current-question-num');
    const progressFill = document.getElementById('progress-fill');
    const questionGrid = document.getElementById('question-grid');
    const questionNavigator = document.getElementById('question-navigator');
    const reviewToggle = document.getElementById('review-toggle');
    const closeNavigator = document.getElementById('close-navigator');
    const navigatorSubmit = document.getElementById('navigator-submit');
    const filterButtons = document.querySelectorAll('.filter-button');
    
    // Counter elements
    const countAll = document.getElementById('count-all');
    const countAnswered = document.getElementById('count-answered');
    const countFlagged = document.getElementById('count-flagged');
    const countUnanswered = document.getElementById('count-unanswered');
    
    // Modal elements
    const submitModal = document.getElementById('submit-modal');
    const closeSubmitModal = document.getElementById('close-submit-modal');
    const cancelSubmit = document.getElementById('cancel-submit');
    const confirmSubmit = document.getElementById('confirm-submit');
    const unansweredWarning = document.getElementById('unanswered-warning');
    const unansweredCount = document.getElementById('unanswered-count');
    const timeWarningModal = document.getElementById('time-warning-modal');
    const acknowledgeTimeWarning = document.getElementById('acknowledge-time-warning');
    const closeTimeWarningModal = document.getElementById('close-time-warning-modal');
    
    // Initialize timer
    let timerInterval;
    let timeRemaining = examData.timeLimit;
    let timeWarningShown = false;
    
    // Initialize exam
    initializeExam();
    
    // Set up event listeners
    prevButton.addEventListener('click', goToPreviousQuestion);
    nextButton.addEventListener('click', goToNextQuestion);
    submitButton.addEventListener('click', showSubmitConfirmation);
    flagButton.addEventListener('click', toggleFlagQuestion);
    navigatorSubmit.addEventListener('click', showSubmitConfirmation);
    
    reviewToggle.addEventListener('click', toggleQuestionNavigator);
    closeNavigator.addEventListener('click', toggleQuestionNavigator);
    
    closeSubmitModal.addEventListener('click', closeSubmitConfirmation);
    cancelSubmit.addEventListener('click', closeSubmitConfirmation);
    confirmSubmit.addEventListener('click', submitExam);
    
    acknowledgeTimeWarning.addEventListener('click', closeTimeWarningModal);
    closeTimeWarningModal.addEventListener('click', closeTimeWarningModal);
    
    // Filter button event listeners
    filterButtons.forEach(button => {
      button.addEventListener('click', () => {
        filterButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        filterQuestionGrid(button.dataset.filter);
      });
    });
    
    // Initialize window events
    window.addEventListener('beforeunload', handleBeforeUnload);
    
    // Initialize proctoring if enabled
    if (examData.proctorEnabled) {
      initializeProctoring();
    }
    
    /**
     * Initialize the exam
     */
    function initializeExam() {
      // Build question grid
      buildQuestionGrid();
      
      // Load first question
      loadQuestion(0);
      
      // Start timer
      startTimer();
      
      // Update counters
      updateCounters();
      
      // Set up interval to save answers periodically
      setInterval(saveProgress, 30000); // Every 30 seconds
    }
    
    /**
     * Start the exam timer
     */
    function startTimer() {
      updateTimerDisplay();
      
      timerInterval = setInterval(() => {
        timeRemaining--;
        updateTimerDisplay();
        
        // Check for low time warning (5 minutes)
        if (timeRemaining === 300 && !timeWarningShown) {
          showTimeWarning(5);
          timeWarningShown = true;
        }
        // Check for very low time warning (1 minute)
        else if (timeRemaining === 60 && timeWarningShown === true) {
          showTimeWarning(1);
          timeWarningShown = 'critical';
        }
        
        // Check if time is up
        if (timeRemaining <= 0) {
          clearInterval(timerInterval);
          submitExam(true); // Auto-submit when time expires
        }
      }, 1000);
    }
    
    /**
     * Update the timer display
     */
    function updateTimerDisplay() {
      const hours = Math.floor(timeRemaining / 3600);
      const minutes = Math.floor((timeRemaining % 3600) / 60);
      const seconds = timeRemaining % 60;
      
      timerDisplay.textContent = 
        `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      
      // Add warning class if less than 5 minutes remaining
      if (timeRemaining < 300) {
        timerDisplay.classList.add('timer-warning');
      }
      
      // Add critical class if less than 1 minute remaining
      if (timeRemaining < 60) {
        timerDisplay.classList.remove('timer-warning');
        timerDisplay.classList.add('timer-critical');
      }
    }
    
    /**
     * Show time warning modal
     * @param {number} minutes - Minutes remaining
     */
    function showTimeWarning(minutes) {
      document.getElementById('time-remaining-warning').textContent = 
        `${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`;
      
      timeWarningModal.classList.remove('hidden');
      
      // Log proctor event
      if (examData.proctorEnabled) {
        logProctorEvent('time_warning', { minutesRemaining: minutes });
      }
    }
    
    /**
     * Close time warning modal
     */
    function closeTimeWarningModal() {
      timeWarningModal.classList.add('hidden');
    }
    
    /**
     * Build the question grid in the navigator
     */
    function buildQuestionGrid() {
      questionGrid.innerHTML = '';
      
      examData.questions.forEach((question, index) => {
        const gridItem = document.createElement('div');
        gridItem.className = 'question-grid-item';
        gridItem.textContent = index + 1;
        gridItem.dataset.index = index;
        
        gridItem.addEventListener('click', () => {
          // Save current question answer first
          saveCurrentQuestionAnswer();
          saveCurrentQuestionTime();
          
          // Then navigate
          loadQuestion(index);
          toggleQuestionNavigator();
        });
        
        questionGrid.appendChild(gridItem);
      });
      
      // Initialize count displays
      countAll.textContent = examData.questions.length;
    }
    
    /**
     * Update the question grid status
     */
    function updateQuestionGrid() {
      const gridItems = document.querySelectorAll('.question-grid-item');
      
      gridItems.forEach((item, index) => {
        // Reset classes
        item.classList.remove('answered', 'flagged', 'current');
        
        // Add appropriate classes
        if (index === examData.currentQuestionIndex) {
          item.classList.add('current');
        }
        
        if (examData.answers[index] !== undefined) {
          item.classList.add('answered');
        }
        
        if (examData.flagged.includes(index)) {
          item.classList.add('flagged');
        }
      });
    }
    
    /**
     * Filter the question grid by status
     * @param {string} filter - Filter type: 'all', 'answered', 'flagged', 'unanswered'
     */
    function filterQuestionGrid(filter) {
      const gridItems = document.querySelectorAll('.question-grid-item');
      
      gridItems.forEach((item, index) => {
        const isAnswered = examData.answers[index] !== undefined;
        const isFlagged = examData.flagged.includes(index);
        
        if (filter === 'all') {
          item.classList.remove('hidden');
        } else if (filter === 'answered' && isAnswered) {
          item.classList.remove('hidden');
        } else if (filter === 'flagged' && isFlagged) {
          item.classList.remove('hidden');
        } else if (filter === 'unanswered' && !isAnswered) {
          item.classList.remove('hidden');
        } else {
          item.classList.add('hidden');
        }
      });
    }
    
    /**
     * Update the counter displays
     */
    function updateCounters() {
      const totalQuestions = examData.questions.length;
      const answeredCount = Object.keys(examData.answers).length;
      const flaggedCount = examData.flagged.length;
      const unansweredCount = totalQuestions - answeredCount;
      
      countAll.textContent = totalQuestions;
      countAnswered.textContent = answeredCount;
      countFlagged.textContent = flaggedCount;
      countUnanswered.textContent = unansweredCount;
    }
    
    /**
     * Toggle the question navigator sidebar
     */
    function toggleQuestionNavigator() {
      questionNavigator.classList.toggle('active');
      updateQuestionGrid();
      updateCounters();
    }
    
    /**
     * Load a question by index
     * @param {number} index - Question index
     */
    function loadQuestion(index) {
      // Validate index
      if (index < 0 || index >= examData.questions.length) {
        console.error('Invalid question index:', index);
        return;
      }
      
      // Update current question index
      examData.currentQuestionIndex = index;
      
      // Get the question
      const question = examData.questions[index];
      
      // Update question number display
      currentQuestionNum.textContent = index + 1;
      
      // Update progress bar
      const progressPercentage = ((index + 1) / examData.questions.length) * 100;
      progressFill.style.width = `${progressPercentage}%`;
      
      // Update navigation buttons
      prevButton.disabled = index === 0;
      
      if (index === examData.questions.length - 1) {
        nextButton.classList.add('hidden');
        submitButton.classList.remove('hidden');
      } else {
        nextButton.classList.remove('hidden');
        submitButton.classList.add('hidden');
      }
      
      // Update flag button
      const isFlagged = examData.flagged.includes(index);
      flagButton.dataset.flagged = isFlagged.toString();
      flagText.textContent = isFlagged ? 'Unflag Question' : 'Flag for Review';
      flagButton.classList.toggle('flagged', isFlagged);
      
      // Start tracking time for this question
      examData.timeSpent[index] = examData.timeSpent[index] || 0;
      examData.currentQuestionStartTime = Date.now();
      
      // Render the question
      renderQuestion(question, index);
      
      // Update question grid
      updateQuestionGrid();
    }
    
    /**
     * Render a question in the container
     * @param {Object} question - Question object
     * @param {number} index - Question index
     */
    function renderQuestion(question, index) {
      // Create question HTML
      const questionHtml = `
        <div class="question-text">
          ${question.text}
        </div>
        <div class="options-container">
          ${renderOptions(question.options, index)}
        </div>
      `;
      
      // Update container
      questionContainer.innerHTML = questionHtml;
      
      // Add event listeners to options
      const optionElements = document.querySelectorAll('.option-item');
      optionElements.forEach(option => {
        option.addEventListener('click', () => {
          // For single-answer questions (default behavior)
          document.querySelectorAll('.option-item').forEach(opt => {
            opt.classList.remove('selected');
          });
          
          option.classList.add('selected');
          
          // Save the answer
          const optionId = option.dataset.optionId;
          examData.answers[index] = optionId;
          
          // Update question grid and counters
          updateQuestionGrid();
          updateCounters();
        });
      });
      
      // If there's a saved answer, select it
      if (examData.answers[index] !== undefined) {
        const savedAnswer = examData.answers[index];
        const savedOption = document.querySelector(`.option-item[data-option-id="${savedAnswer}"]`);
        if (savedOption) {
          savedOption.classList.add('selected');
        }
      }
    }
    
    /**
     * Render question options
     * @param {Array} options - Array of option objects
     * @param {number} questionIndex - Question index
     * @returns {string} HTML for options
     */
    function renderOptions(options, questionIndex) {
      return options.map(option => `
        <div class="option-item" data-option-id="${option.id}">
          <div class="option-marker">${option.id}</div>
          <div class="option-text">${option.text}</div>
        </div>
      `).join('');
    }
    
    /**
     * Go to the previous question
     */
    function goToPreviousQuestion() {
      if (examData.currentQuestionIndex > 0) {
        // Save current question data
        saveCurrentQuestionAnswer();
        saveCurrentQuestionTime();
        
        // Load previous question
        loadQuestion(examData.currentQuestionIndex - 1);
      }
    }
    
    /**
     * Go to the next question
     */
    function goToNextQuestion() {
      if (examData.currentQuestionIndex < examData.questions.length - 1) {
        // Save current question data
        saveCurrentQuestionAnswer();
        saveCurrentQuestionTime();
        
        // Load next question
        loadQuestion(examData.currentQuestionIndex + 1);
      }
    }
    
    /**
     * Toggle the flag status of the current question
     */
    function toggleFlagQuestion() {
      const currentIndex = examData.currentQuestionIndex;
      const isFlagged = examData.flagged.includes(currentIndex);
      
      if (isFlagged) {
        // Remove from flagged array
        examData.flagged = examData.flagged.filter(index => index !== currentIndex);
      } else {
        // Add to flagged array
        examData.flagged.push(currentIndex);
      }
      
      // Update UI
      const newFlagStatus = !isFlagged;
      flagButton.dataset.flagged = newFlagStatus.toString();
      flagText.textContent = newFlagStatus ? 'Unflag Question' : 'Flag for Review';
      flagButton.classList.toggle('flagged', newFlagStatus);
      
      // Update question grid
      updateQuestionGrid();
      updateCounters();
    }
    
    /**
     * Save the current question's answer
     */
    function saveCurrentQuestionAnswer() {
      const currentIndex = examData.currentQuestionIndex;
      const selectedOption = document.querySelector('.option-item.selected');
      
      if (selectedOption) {
        examData.answers[currentIndex] = selectedOption.dataset.optionId;
      }
    }
    
    /**
     * Save the time spent on the current question
     */
    function saveCurrentQuestionTime() {
      const currentIndex = examData.currentQuestionIndex;
      const timeSpent = Math.floor((Date.now() - examData.currentQuestionStartTime) / 1000);
      
      examData.timeSpent[currentIndex] = (examData.timeSpent[currentIndex] || 0) + timeSpent;
      examData.currentQuestionStartTime = Date.now();
    }
    
    /**
     * Save exam progress (for auto-save)
     */
    function saveProgress() {
      // Save current question first
      saveCurrentQuestionAnswer();
      saveCurrentQuestionTime();
      
      // TODO: Implement API call to save progress if needed
      console.log('Progress saved automatically');
    }
    
    /**
     * Show submit confirmation modal
     */
    function showSubmitConfirmation() {
      // Save current answers before showing confirmation
      saveCurrentQuestionAnswer();
      saveCurrentQuestionTime();
      
      // Check if there are unanswered questions
      const answeredCount = Object.keys(examData.answers).length;
      const unansweredQuestionsCount = examData.questions.length - answeredCount;
      
      if (unansweredQuestionsCount > 0) {
        unansweredWarning.classList.remove('hidden');
        unansweredCount.textContent = unansweredQuestionsCount;
      } else {
        unansweredWarning.classList.add('hidden');
      }
      
      submitModal.classList.remove('hidden');
    }
    
    /**
     * Close submit confirmation modal
     */
    function closeSubmitConfirmation() {
      submitModal.classList.add('hidden');
    }
    
    /**
     * Submit the exam
     * @param {boolean} autoSubmit - Whether this is an automatic submission (e.g., timer expired)
     */
    function submitExam(autoSubmit = false) {
      // Stop timer
      clearInterval(timerInterval);
      
      // Save final answers and time
      saveCurrentQuestionAnswer();
      saveCurrentQuestionTime();
      
      // Calculate total time spent
      const totalTimeSpent = examData.timeLimit - timeRemaining;
      
      // Prepare submission data
      const submissionData = {
        attemptId: examData.id,
        answers: examData.answers,
        timeSpentPerQuestion: examData.timeSpent,
        flaggedQuestions: examData.flagged,
        totalTimeSpent: totalTimeSpent,
        autoSubmitted: autoSubmit
      };
      
      // Add proctor events if proctoring was enabled
      if (examData.proctorEnabled) {
        submissionData.proctorEvents = examData.proctorEvents;
      }
      
      // Disable UI elements to prevent further interaction
      disableExamInterface();
      
      // Show loading indicator
      showLoadingOverlay('Submitting your exam...');
      
      // Submit the exam
      fetch('/exams/submit', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(submissionData)
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // Redirect to results page
          window.location.href = `/exams/results/${data.attemptId}`;
        } else {
          // Show error
          hideLoadingOverlay();
          showAlert(data.message || 'Failed to submit exam. Please try again.', 'error');
          
          // Re-enable interface
          enableExamInterface();
          
          // Restart timer if not auto-submitted
          if (!autoSubmit) {
            startTimer();
          }
        }
      })
      .catch(error => {
        console.error('Error submitting exam:', error);
        hideLoadingOverlay();
        showAlert('Network error. Please try again.', 'error');
        
        // Re-enable interface
        enableExamInterface();
        
        // Restart timer if not auto-submitted
        if (!autoSubmit) {
          startTimer();
        }
      });
    }
    
    /**
     * Disable exam interface during submission
     */
    function disableExamInterface() {
      prevButton.disabled = true;
      nextButton.disabled = true;
      submitButton.disabled = true;
      flagButton.disabled = true;
      
      const optionElements = document.querySelectorAll('.option-item');
      optionElements.forEach(option => {
        option.style.pointerEvents = 'none';
      });
      
      document.querySelectorAll('.question-grid-item').forEach(item => {
        item.style.pointerEvents = 'none';
      });
    }
    
    /**
     * Enable exam interface
     */
    function enableExamInterface() {
      prevButton.disabled = examData.currentQuestionIndex === 0;
      nextButton.disabled = false;
      submitButton.disabled = false;
      flagButton.disabled = false;
      
      const optionElements = document.querySelectorAll('.option-item');
      optionElements.forEach(option => {
        option.style.pointerEvents = 'auto';
      });
      
      document.querySelectorAll('.question-grid-item').forEach(item => {
        item.style.pointerEvents = 'auto';
      });
    }
    
    /**
     * Show loading overlay
     * @param {string} message - Loading message
     */
    function showLoadingOverlay(message = 'Loading...') {
      // Create overlay if it doesn't exist
      if (!document.getElementById('loading-overlay')) {
        const overlay = document.createElement('div');
        overlay.id = 'loading-overlay';
        overlay.className = 'loading-overlay';
        overlay.innerHTML = `
          <div class="loading-content">
            <div class="spinner"></div>
            <p id="loading-message" class="loading-message">${message}</p>
          </div>
        `;
        document.body.appendChild(overlay);
      } else {
        document.getElementById('loading-message').textContent = message;
        document.getElementById('loading-overlay').classList.remove('hidden');
      }
    }
    
    /**
     * Hide loading overlay
     */
    function hideLoadingOverlay() {
      const overlay = document.getElementById('loading-overlay');
      if (overlay) {
        overlay.classList.add('hidden');
      }
    }
    
    /**
     * Handle beforeunload event
     * @param {BeforeUnloadEvent} event - The beforeunload event
     */
    function handleBeforeUnload(event) {
      // Prevent accidental navigation away from exam
      event.preventDefault();
      event.returnValue = 'You are in the middle of an exam. Are you sure you want to leave?';
      
      // Log proctor event if proctoring is enabled
      if (examData.proctorEnabled) {
        logProctorEvent('page_exit_attempt', {
          timestamp: new Date().toISOString()
        });
      }
      
      return event.returnValue;
    }
    
    /**
     * Initialize proctoring
     */
    function initializeProctoring() {
      const webcamContainer = document.getElementById('proctor-webcam-container');
      const webcamElement = document.getElementById('proctor-webcam');
      const statusIndicator = document.getElementById('proctor-status-indicator');
      const statusText = document.getElementById('proctor-status-text');
      
      // Try to get webcam access
      navigator.mediaDevices.getUserMedia({ video: true, audio: false })
        .then(stream => {
          webcamElement.srcObject = stream;
          
          // Log successful initialization
          logProctorEvent('proctor_initialized', {
            webcamActive: true
          });
          
          // Start face detection check interval
          startFaceDetectionCheck();
        })
        .catch(error => {
          console.error('Webcam access error:', error);
          
          // Show webcam permission modal
          document.getElementById('webcam-permission-modal').classList.remove('hidden');
          
          // Update status display
          statusIndicator.className = 'status-indicator status-error';
          statusText.textContent = 'Camera Access Required';
          
          // Log failure
          logProctorEvent('proctor_initialization_failed', {
            error: error.message
          });
          
          // Add retry button event listener
          document.getElementById('retry-webcam').addEventListener('click', () => {
            document.getElementById('webcam-permission-modal').classList.add('hidden');
            initializeProctoring();
          });
        });
        
      // Set up tab visibility monitoring
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          logProctorEvent('tab_switch', {
            timestamp: new Date().toISOString(),
            visibilityState: 'hidden'
          });
        } else {
          logProctorEvent('tab_switch', {
            timestamp: new Date().toISOString(),
            visibilityState: 'visible'
          });
        }
      });
      
      // Monitor browser focus
      window.addEventListener('blur', () => {
        logProctorEvent('window_blur', {
          timestamp: new Date().toISOString()
        });
      });
      
      window.addEventListener('focus', () => {
        logProctorEvent('window_focus', {
          timestamp: new Date().toISOString()
        });
      });
    }
    
    /**
     * Start face detection check interval
     * Simple simulation - in a real implementation, this would use TensorFlow.js
     */
    function startFaceDetectionCheck() {
      // Simulate face detection with random checks
      // In a real implementation, this would use TensorFlow.js/face-api.js
      setInterval(() => {
        const faceDetected = Math.random() > 0.1; // 90% chance of success for simulation
        
        if (!faceDetected) {
          // Log face not visible event
          logProctorEvent('face_not_visible', {
            timestamp: new Date().toISOString()
          });
          
          // Show warning if multiple consecutive failures
          const recentFaceEvents = examData.proctorEvents
            .filter(e => e.type === 'face_not_visible')
            .filter(e => new Date(e.details.timestamp) > new Date(Date.now() - 60000));
            
          if (recentFaceEvents.length >= 3) {
            showProctorWarning('Your face must remain visible during the exam.');
          }
        }
      }, 10000); // Check every 10 seconds
    }
    
    /**
     * Log a proctor event
     * @param {string} type - Event type
     * @param {Object} details - Event details
     */
    function logProctorEvent(type, details = {}) {
      const event = {
        type,
        details: {
          ...details,
          timestamp: details.timestamp || new Date().toISOString()
        }
      };
      
      // Add to local events array
      examData.proctorEvents.push(event);
      
      // Send to server for real-time monitoring
      fetch('/exams/proctor/log', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          attemptId: examData.id,
          type: event.type,
          details: event.details
        })
      }).catch(error => {
        console.warn('Failed to log proctor event:', error);
      });
    }
    
    /**
     * Show proctor warning modal
     * @param {string} message - Warning message
     */
    function showProctorWarning(message) {
      const warningModal = document.getElementById('proctor-warning-modal');
      const warningMessage = document.getElementById('proctor-warning-message');
      
      warningMessage.textContent = message;
      warningModal.classList.remove('hidden');
      
      // Add event listener to acknowledge button
      document.getElementById('acknowledge-proctor-warning').addEventListener('click', () => {
        warningModal.classList.add('hidden');
      });
      
      // Add event listener to close button
      document.getElementById('close-proctor-warning').addEventListener('click', () => {
        warningModal.classList.add('hidden');
      });
    }
    
    /**
     * Show alert notification
     * @param {string} message - The message to display
     * @param {string} type - Alert type: 'success', 'error', 'info', 'warning'
     */
    function showAlert(message, type = 'info') {
      // Create container if it doesn't exist
      let alertContainer = document.getElementById('alert-container');
      if (!alertContainer) {
        alertContainer = document.createElement('div');
        alertContainer.id = 'alert-container';
        alertContainer.className = 'fixed top-4 right-4 z-50 flex flex-col space-y-2';
        document.body.appendChild(alertContainer);
      }
      
      // Create alert element
      const alert = document.createElement('div');
      alert.className = `alert alert-${type} transform transition-all duration-300 translate-x-full`;
      
      // Set icon based on type
      let icon;
      if (type === 'success') {
        icon = '<i class="fas fa-check-circle text-green-500"></i>';
      } else if (type === 'error') {
        icon = '<i class="fas fa-exclamation-circle text-red-500"></i>';
      } else if (type === 'warning') {
        icon = '<i class="fas fa-exclamation-triangle text-yellow-500"></i>';
      } else {
        icon = '<i class="fas fa-info-circle text-blue-500"></i>';
      }
      
      // Set content
      alert.innerHTML = `
        <div class="flex items-center">
          <div class="flex-shrink-0">
            ${icon}
          </div>
          <div class="ml-3">
            <p class="text-sm font-medium">${message}</p>
          </div>
          <div class="ml-auto pl-3">
            <button class="alert-close">
              <i class="fas fa-times text-gray-400 hover:text-gray-500"></i>
            </button>
          </div>
        </div>
      `;
      
      // Add color classes based on type
      if (type === 'success') {
        alert.classList.add('bg-green-50', 'border-green-100', 'text-green-800');
      } else if (type === 'error') {
        alert.classList.add('bg-red-50', 'border-red-100', 'text-red-800');
      } else if (type === 'warning') {
        alert.classList.add('bg-yellow-50', 'border-yellow-100', 'text-yellow-800');
      } else {
        alert.classList.add('bg-blue-50', 'border-blue-100', 'text-blue-800');
      }
      
      // Add base styles
      alert.classList.add('rounded-md', 'p-4', 'border', 'shadow-md', 'w-80');
      
      // Add to container
      alertContainer.appendChild(alert);
      
      // Animate in
      setTimeout(() => {
        alert.classList.remove('translate-x-full');
      }, 10);
      
      // Add close handler
      alert.querySelector('.alert-close').addEventListener('click', () => {
        alert.classList.add('translate-x-full');
        setTimeout(() => {
          alert.remove();
        }, 300);
      });
      
      // Auto dismiss after 5 seconds
      setTimeout(() => {
        if (alert.parentNode) {
          alert.classList.add('translate-x-full');
          setTimeout(() => {
            alert.remove();
          }, 300);
        }
      }, 5000);
    }
  });
</script>

<!-- Exam Styling -->
<style>
  /* Base layout */
  .exam-container {
    @apply min-h-screen flex flex-col bg-gray-50;
  }
  
  .exam-header {
    @apply bg-white border-b border-gray-200 py-4 shadow-sm z-10 sticky top-0;
  }
  
  .exam-title {
    @apply text-xl font-semibold text-gray-800;
  }
  
  .exam-certification {
    @apply text-sm text-gray-500;
  }
  
  .timer-container {
    @apply flex items-center;
  }
  
  .timer {
    @apply text-lg font-mono font-semibold text-gray-700 px-4 py-2 rounded-md bg-gray-100;
  }
  
  .timer-warning {
    @apply text-yellow-600 bg-yellow-100;
  }
  
  .timer-critical {
    @apply text-red-600 bg-red-100 animate-pulse;
  }
  
  /* Main exam area */
  .exam-main {
    @apply bg-white rounded-lg shadow-md p-6 my-6 relative overflow-hidden;
  }
  
  .progress-container {
    @apply mb-6;
  }
  
  .question-progress {
    @apply text-sm font-medium text-gray-600;
  }
  
  .progress-bar {
    @apply w-full bg-gray-200 rounded-full h-2 mt-2;
  }
  
  .progress-fill {
    @apply bg-blue-600 h-2 rounded-full transition-all duration-300 ease-out;
  }
  
  .review-toggle {
    @apply text-sm text-blue-600 hover:text-blue-800 focus:outline-none;
  }
  
  /* Question styles */
  .question-container {
    @apply mb-8;
  }
  
  .question-text {
    @apply text-lg text-gray-800 mb-6 leading-relaxed;
  }
  
  .options-container {
    @apply space-y-4;
  }
  
  .option-item {
    @apply flex items-start p-4 border border-gray-300 rounded-md cursor-pointer hover:bg-gray-50 transition-colors;
  }
  
  .option-item.selected {
    @apply bg-blue-50 border-blue-500;
  }
  
  .option-marker {
    @apply flex-shrink-0 w-8 h-8 rounded-full bg-gray-100 flex items-center justify-center font-medium text-gray-700 mr-3;
  }
  
  .option-item.selected .option-marker {
    @apply bg-blue-600 text-white;
  }
  
  .option-text {
    @apply text-gray-700 flex-grow pt-1;
  }
  
  .option-item.selected .option-text {
    @apply text-blue-900 font-medium;
  }
  
  /* Navigation controls */
  .navigation-controls {
    @apply flex flex-wrap items-center justify-between mt-8 space-y-4 sm:space-y-0;
  }
  
  .nav-button {
    @apply inline-flex items-center px-4 py-2 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed;
  }
  
  .submit-button {
    @apply inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500;
  }
  
  .flag-button {
    @apply inline-flex items-center px-4 py-2 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500;
  }
  
  .flag-button.flagged {
    @apply bg-yellow-50 text-yellow-700 border-yellow-300;
  }
  
  .flag-button.flagged i {
    @apply text-yellow-500;
  }
  
  /* Question navigator */
  .question-navigator {
    @apply fixed top-0 right-0 h-full w-64 md:w-80 bg-white shadow-lg transform translate-x-full transition-transform duration-300 ease-in-out z-20 flex flex-col overflow-hidden;
  }
  
  .question-navigator.active {
    @apply translate-x-0;
  }
  
  .navigator-header {
    @apply p-4 bg-gray-800 text-white flex justify-between items-center;
  }
  
  .navigator-title {
    @apply text-lg font-medium;
  }
  
  .close-navigator {
    @apply text-gray-300 hover:text-white focus:outline-none;
  }
  
  .navigator-filters {
    @apply flex flex-wrap p-3 bg-gray-100 gap-2;
  }
  
  .filter-button {
    @apply text-xs py-1 px-2 rounded-full border border-gray-300 bg-white text-gray-700 hover:bg-gray-50;
  }
  
  .filter-button.active {
    @apply bg-blue-100 text-blue-800 border-blue-300;
  }
  
  .question-grid {
    @apply p-4 grid grid-cols-5 gap-2 overflow-y-auto flex-grow;
  }
  
  .question-grid-item {
    @apply w-full aspect-square flex items-center justify-center rounded border border-gray-300 bg-white text-sm font-medium text-gray-700 cursor-pointer hover:border-blue-500 hover:text-blue-600;
  }
  
  .question-grid-item.current {
    @apply bg-blue-600 text-white border-blue-600;
  }
  
  .question-grid-item.answered {
    @apply bg-green-100 border-green-300 text-green-800;
  }
  
  .question-grid-item.flagged {
    @apply border-yellow-400;
  }
  
  .question-grid-item.answered.flagged {
    @apply bg-green-100 border-yellow-400;
  }
  
  .question-grid-item.current.flagged {
    @apply bg-blue-600 text-white border-yellow-400 border-2;
  }
  
  .navigator-footer {
    @apply p-4 bg-gray-100 border-t border-gray-200;
  }
  
  .navigator-submit {
    @apply w-full inline-flex justify-center items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500;
  }
  
  /* Proctor webcam */
  .proctor-webcam-container {
    @apply fixed bottom-4 right-4 w-40 h-30 bg-black rounded-md overflow-hidden shadow-lg border-2 border-gray-800 z-10;
  }
  
  .proctor-status {
    @apply absolute bottom-0 left-0 right-0 bg-black bg-opacity-75 text-white text-xs py-1 px-2 flex items-center;
  }
  
  .status-indicator {
    @apply w-2 h-2 rounded-full mr-2;
  }
  
  .status-active {
    @apply bg-green-500;
  }
  
  .status-warning {
    @apply bg-yellow-500;
  }
  
  .status-error {
    @apply bg-red-500;
  }
  
  .status-text {
    @apply text-xs font-medium;
  }
  
  /* Modal styles */
  .modal {
    @apply fixed inset-0 z-50 overflow-y-auto;
  }
  
  .modal-overlay {
    @apply fixed inset-0 bg-black bg-opacity-50;
  }
  
  .modal-container {
    @apply bg-white rounded-lg shadow-xl mx-auto my-8 max-w-lg overflow-hidden relative;
  }
  
  .modal-header {
    @apply px-6 py-4 bg-white border-b border-gray-200 flex justify-between items-center;
  }
  
  .modal-close {
    @apply text-gray-400 hover:text-gray-500;
  }
  
  .modal-body {
    @apply px-6 py-4;
  }
  
  .modal-footer {
    @apply px-6 py-4 bg-gray-50 border-t border-gray-200 flex justify-end space-x-3;
  }
  
  .modal-footer.justify-center {
    @apply justify-center;
  }
  
  /* Button styles */
  .btn {
    @apply inline-flex items-center px-4 py-2 border text-sm font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500;
  }
  
  .btn-primary {
    @apply border-transparent text-white bg-blue-600 hover:bg-blue-700;
  }
  
  .btn-warning {
    @apply border-transparent text-white bg-yellow-600 hover:bg-yellow-700;
  }
  
  .btn-danger {
    @apply border-transparent text-white bg-red-600 hover:bg-red-700;
  }
  
  .btn-outline {
    @apply border-gray-300 text-gray-700 bg-white hover:bg-gray-50;
  }
  
  /* Loading overlay */
  .loading-overlay {
    @apply fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50;
  }
  
  .loading-content {
    @apply bg-white rounded-lg p-6 max-w-sm mx-auto text-center;
  }
  
  .spinner {
    @apply w-12 h-12 border-4 border-blue-200 border-t-blue-600 rounded-full animate-spin mx-auto;
  }
  
  .loading-message {
    @apply mt-4 text-gray-700;
  }
  
  /* Helper classes */
  .hidden {
    @apply hidden;
  }
</style>

<%- include('../layouts/footer') %>