<!-- views/exams/exam.ejs -->
<%- include('../layouts/exam-layout', { title: title }) %>


<div id="exam-container" class="exam-container">
  <!-- Header -->
  <header class="exam-header">
    <div class="container mx-auto px-4 flex justify-between items-center">
      <div class="exam-info">
        <h1 id="exam-title" class="exam-title"><%= exam.name %></h1>
        <div class="exam-certification"><%= certification.name %></div>
      </div>
      <div id="timer-container" class="timer-container">
        <div id="timer" class="timer">
          <i class="far fa-clock mr-2"></i>
          <span id="timer-display">00:00:00</span>
        </div>
      </div>
    </div>
  </header>

  <div class="container mx-auto px-4 py-6">
    <div class="flex flex-col md:flex-row">
      <!-- Main Exam Area -->
      <main class="exam-main flex-grow">
        <!-- Progress Bar -->
        <div class="progress-container mb-6">
          <div class="flex justify-between items-center mb-2">
            <div id="question-progress" class="question-progress">
              Question <span id="current-question-num">1</span> of <span id="total-questions"><%= questions.length %></span>
            </div>
            <div class="flex items-center">
              <button id="review-toggle" class="review-toggle">
                <i class="fas fa-list mr-2"></i> Review All
              </button>
            </div>
          </div>
          <div class="progress-bar">
            <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
          </div>
        </div>

        <!-- Question Content -->
        <div id="question-container" class="question-container">
          <!-- Will be populated dynamically -->
        </div>

        <!-- Navigation Controls -->
        <div id="navigation-controls" class="navigation-controls">
          <button id="prev-button" class="nav-button prev-button" disabled>
            <i class="fas fa-chevron-left mr-2"></i> Previous
          </button>
          <button id="flag-button" class="flag-button" data-flagged="false">
            <i class="far fa-flag mr-2"></i> <span id="flag-text">Flag for Review</span>
          </button>
          <button id="next-button" class="nav-button next-button">
            Next <i class="fas fa-chevron-right ml-2"></i>
          </button>
          <button id="submit-button" class="submit-button hidden">
            Submit Exam
          </button>
        </div>
      </main>

      <!-- Right Sidebar (Question Navigator) -->
      <aside id="question-navigator" class="question-navigator">
        <div class="navigator-header">
          <h2 class="navigator-title">Question Navigator</h2>
          <button id="close-navigator" class="close-navigator">
            <i class="fas fa-times"></i>
          </button>
        </div>
        
        <div class="navigator-filters">
          <button class="filter-button active" data-filter="all">All (<span id="count-all">0</span>)</button>
          <button class="filter-button" data-filter="answered">Answered (<span id="count-answered">0</span>)</button>
          <button class="filter-button" data-filter="flagged">Flagged (<span id="count-flagged">0</span>)</button>
          <button class="filter-button" data-filter="unanswered">Unanswered (<span id="count-unanswered">0</span>)</button>
        </div>
        
        <div id="question-grid" class="question-grid">
          <!-- Will be populated dynamically -->
        </div>
        
        <div class="navigator-footer">
          <button id="navigator-submit" class="navigator-submit">Submit Exam</button>
        </div>
      </aside>

      <!-- Proctor Webcam (if enabled) -->
      <% if (proctorEnabled) { %>
        <div id="proctor-webcam-container" class="proctor-webcam-container">
          <video id="proctor-webcam" autoplay playsinline muted></video>
          <div class="proctor-status">
            <div id="proctor-status-indicator" class="status-indicator status-active"></div>
            <div id="proctor-status-text" class="status-text">Proctoring Active</div>
          </div>
        </div>
      <% } %>
    </div>
  </div>
</div>

<!-- Exam Modals -->

<!-- Submit Confirmation Modal -->
<div id="submit-modal" class="modal hidden">
  <div class="modal-overlay"></div>
  <div class="modal-container max-w-md">
    <div class="modal-header">
      <h2>Submit Exam</h2>
      <button id="close-submit-modal" class="modal-close">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <p>Are you sure you want to submit your exam? Once submitted, you will not be able to return to the exam.</p>
      
      <div id="unanswered-warning" class="mt-4 hidden">
        <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4">
          <div class="flex">
            <div class="flex-shrink-0">
              <i class="fas fa-exclamation-triangle text-yellow-400"></i>
            </div>
            <div class="ml-3">
              <p class="text-sm text-yellow-700">
                <span id="unanswered-count">0</span> questions remain unanswered.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button id="confirm-submit" class="btn btn-danger">Submit Exam</button>
      <button id="cancel-submit" class="btn btn-outline">Continue Exam</button>
    </div>
  </div>
</div>

<!-- Time Warning Modal -->
<div id="time-warning-modal" class="modal hidden">
  <div class="modal-overlay"></div>
  <div class="modal-container max-w-md">
    <div class="modal-header">
      <h2>Time Running Out</h2>
      <button id="close-time-warning-modal" class="modal-close">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <div class="text-center mb-4">
        <i class="far fa-clock text-4xl text-yellow-500"></i>
      </div>
      <p class="text-center">You have <span id="time-remaining-warning">5 minutes</span> remaining in this exam.</p>
    </div>
    <div class="modal-footer justify-center">
      <button id="acknowledge-time-warning" class="btn btn-primary">Continue Exam</button>
    </div>
  </div>
</div>

<!-- Proctor Warning Modal -->
<div id="proctor-warning-modal" class="modal hidden">
  <div class="modal-overlay"></div>
  <div class="modal-container max-w-md">
    <div class="modal-header bg-yellow-50">
      <h2 class="text-yellow-800">Proctor Warning</h2>
      <button id="close-proctor-warning" class="modal-close">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <div class="text-center mb-4">
        <i class="fas fa-exclamation-triangle text-4xl text-yellow-500"></i>
      </div>
      <p id="proctor-warning-message" class="text-center">
        Your face must remain visible during the exam.
      </p>
    </div>
    <div class="modal-footer justify-center">
      <button id="acknowledge-proctor-warning" class="btn btn-warning">I Understand</button>
    </div>
  </div>
</div>

<!-- Webcam Permission Modal -->
<div id="webcam-permission-modal" class="modal hidden">
  <div class="modal-overlay"></div>
  <div class="modal-container max-w-md">
    <div class="modal-header">
      <h2>Camera Access Required</h2>
    </div>
    <div class="modal-body">
      <div class="text-center mb-4">
        <i class="fas fa-video text-4xl text-blue-500"></i>
      </div>
      <p class="text-center">
        This exam is proctored and requires webcam access. Please allow camera access to continue.
      </p>
      <div class="bg-blue-50 border-l-4 border-blue-400 p-4 mt-4">
        <div class="flex">
          <div class="flex-shrink-0">
            <i class="fas fa-info-circle text-blue-400"></i>
          </div>
          <div class="ml-3">
            <p class="text-sm text-blue-700">
              Your webcam feed is only used for proctoring during this exam session and is not recorded.
            </p>
          </div>
        </div>
      </div>
    </div>
    <div class="modal-footer justify-center">
      <button id="retry-webcam" class="btn btn-primary">Allow Camera Access</button>
    </div>
  </div>
</div>

<!-- Data Storage -->
<script>
    // Initialize exam data
    let examData = {
      id: '<%= attempt._id %>',
      timeLimit: <%= (exam.timeLimit || certification.timeLimit) %> * 60, // Convert minutes to seconds
      questions: <%- JSON.stringify(questions) %>,
      proctorEnabled: <%= proctorEnabled %>,
      answers: {},
      timeSpent: {},
      flagged: [],
      currentQuestionIndex: 0,
      startTime: Date.now(),
      endTime: null,
      proctorEvents: []
    };
  
    // Initialize with existing data if available
    <% if (typeof userAnswers !== 'undefined' && userAnswers) { %>
      examData.answers = <%- JSON.stringify(userAnswers) %>;
    <% } %>
  
    <% if (attempt && attempt.questions) { %>
      // Initialize timeSpent from attempt data
      examData.timeSpent = {};
      <% attempt.questions.forEach(q => { %>
        <% if (q.timeSpent) { %>
          examData.timeSpent['<%= q.questionId %>'] = <%= q.timeSpent %>;
        <% } %>
      <% }); %>
      
      // Initialize flagged questions
      examData.flagged = [];
      <% attempt.questions.forEach((q, idx) => { %>
        <% if (q.flagged) { %>
          examData.flagged.push(<%= idx %>);
        <% } %>
      <% }); %>
    <% } %>
  </script>


<!-- Main Exam Logic -->
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // DOM Elements
    const timerDisplay = document.getElementById('timer-display');
    const questionContainer = document.getElementById('question-container');
    const prevButton = document.getElementById('prev-button');
    const nextButton = document.getElementById('next-button');
    const submitButton = document.getElementById('submit-button');
    const flagButton = document.getElementById('flag-button');
    const flagText = document.getElementById('flag-text');
    const currentQuestionNum = document.getElementById('current-question-num');
    const progressFill = document.getElementById('progress-fill');
    const questionGrid = document.getElementById('question-grid');
    const questionNavigator = document.getElementById('question-navigator');
    const reviewToggle = document.getElementById('review-toggle');
    const closeNavigator = document.getElementById('close-navigator');
    const navigatorSubmit = document.getElementById('navigator-submit');
    const filterButtons = document.querySelectorAll('.filter-button');
    
    // Counter elements
    const countAll = document.getElementById('count-all');
    const countAnswered = document.getElementById('count-answered');
    const countFlagged = document.getElementById('count-flagged');
    const countUnanswered = document.getElementById('count-unanswered');
    
    // Modal elements
    const submitModal = document.getElementById('submit-modal');
    const closeSubmitModal = document.getElementById('close-submit-modal');
    const cancelSubmit = document.getElementById('cancel-submit');
    const confirmSubmit = document.getElementById('confirm-submit');
    const unansweredWarning = document.getElementById('unanswered-warning');
    const unansweredCount = document.getElementById('unanswered-count');
    const timeWarningModal = document.getElementById('time-warning-modal');
    const acknowledgeTimeWarning = document.getElementById('acknowledge-time-warning');
    const closeTimeWarningModal = document.getElementById('close-time-warning-modal');
    
    // Initialize timer
    let timerInterval;
    let timeRemaining = examData.timeLimit;
    let timeWarningShown = false;
    
    // Initialize exam
    initializeExam();
    
    // Set up event listeners
    prevButton.addEventListener('click', goToPreviousQuestion);
    nextButton.addEventListener('click', goToNextQuestion);
    submitButton.addEventListener('click', showSubmitConfirmation);
    flagButton.addEventListener('click', toggleFlagQuestion);
    navigatorSubmit.addEventListener('click', showSubmitConfirmation);
    
    reviewToggle.addEventListener('click', toggleQuestionNavigator);
    closeNavigator.addEventListener('click', toggleQuestionNavigator);
    
    closeSubmitModal.addEventListener('click', closeSubmitConfirmation);
    cancelSubmit.addEventListener('click', closeSubmitConfirmation);
    confirmSubmit.addEventListener('click', submitExam);
    
    acknowledgeTimeWarning.addEventListener('click', closeTimeWarningModal);
    closeTimeWarningModal.addEventListener('click', closeTimeWarningModal);
    
    // Filter button event listeners
    filterButtons.forEach(button => {
      button.addEventListener('click', () => {
        filterButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        filterQuestionGrid(button.dataset.filter);
      });
    });
    
    // Initialize window events
    window.addEventListener('beforeunload', handleBeforeUnload);
    
    // Initialize proctoring if enabled
    if (examData.proctorEnabled) {
      initializeProctoring();
    }
    
    /**
     * Initialize the exam
     */
    function initializeExam() {
      // Build question grid
      buildQuestionGrid();
      
      // Load first question
      loadQuestion(0);
      
      // Start timer
      startTimer();
      
      // Update counters
      updateCounters();
      
      // Set up interval to save answers periodically
      setInterval(saveProgress, 30000); // Every 30 seconds
    }
    
    /**
     * Start the exam timer
     */
    function startTimer() {
      updateTimerDisplay();
      
      timerInterval = setInterval(() => {
        timeRemaining--;
        updateTimerDisplay();
        
        // Check for low time warning (5 minutes)
        if (timeRemaining === 300 && !timeWarningShown) {
          showTimeWarning(5);
          timeWarningShown = true;
        }
        // Check for very low time warning (1 minute)
        else if (timeRemaining === 60 && timeWarningShown === true) {
          showTimeWarning(1);
          timeWarningShown = 'critical';
        }
        
        // Check if time is up
        if (timeRemaining <= 0) {
          clearInterval(timerInterval);
          submitExam(true); // Auto-submit when time expires
        }
      }, 1000);
    }
    
    /**
     * Update the timer display
     */
    function updateTimerDisplay() {
      const hours = Math.floor(timeRemaining / 3600);
      const minutes = Math.floor((timeRemaining % 3600) / 60);
      const seconds = timeRemaining % 60;
      
      timerDisplay.textContent = 
        `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      
      // Add warning class if less than 5 minutes remaining
      if (timeRemaining < 300) {
        timerDisplay.classList.add('timer-warning');
      }
      
      // Add critical class if less than 1 minute remaining
      if (timeRemaining < 60) {
        timerDisplay.classList.remove('timer-warning');
        timerDisplay.classList.add('timer-critical');
      }
    }
    
    /**
     * Show time warning modal
     * @param {number} minutes - Minutes remaining
     */
    function showTimeWarning(minutes) {
      document.getElementById('time-remaining-warning').textContent = 
        `${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`;
      
      timeWarningModal.classList.remove('hidden');
      
      // Log proctor event
      if (examData.proctorEnabled) {
        logProctorEvent('time_warning', { minutesRemaining: minutes });
      }
    }
    
    /**
     * Close time warning modal
     */
    function closeTimeWarningModal() {
      timeWarningModal.classList.add('hidden');
    }
    
    /**
     * Build the question grid in the navigator
     */
    function buildQuestionGrid() {
      questionGrid.innerHTML = '';
      
      examData.questions.forEach((question, index) => {
        const gridItem = document.createElement('div');
        gridItem.className = 'question-grid-item';
        gridItem.textContent = index + 1;
        gridItem.dataset.index = index;
        
        gridItem.addEventListener('click', () => {
          // Save current question answer first
          saveCurrentQuestionAnswer();
          saveCurrentQuestionTime();
          
          // Then navigate
          loadQuestion(index);
          toggleQuestionNavigator();
        });
        
        questionGrid.appendChild(gridItem);
      });
      
      // Initialize count displays
      countAll.textContent = examData.questions.length;
    }
    
    /**
     * Update the question grid status
     */
    function updateQuestionGrid() {
      const gridItems = document.querySelectorAll('.question-grid-item');
      
      gridItems.forEach((item, index) => {
        // Reset classes
        item.classList.remove('answered', 'flagged', 'current');
        
        // Add appropriate classes
        if (index === examData.currentQuestionIndex) {
          item.classList.add('current');
        }
        
        if (examData.answers[index] !== undefined) {
          item.classList.add('answered');
        }
        
        if (examData.flagged.includes(index)) {
          item.classList.add('flagged');
        }
      });
    }
    
    /**
     * Filter the question grid by status
     * @param {string} filter - Filter type: 'all', 'answered', 'flagged', 'unanswered'
     */
    function filterQuestionGrid(filter) {
      const gridItems = document.querySelectorAll('.question-grid-item');
      
      gridItems.forEach((item, index) => {
        const isAnswered = examData.answers[index] !== undefined;
        const isFlagged = examData.flagged.includes(index);
        
        if (filter === 'all') {
          item.classList.remove('hidden');
        } else if (filter === 'answered' && isAnswered) {
          item.classList.remove('hidden');
        } else if (filter === 'flagged' && isFlagged) {
          item.classList.remove('hidden');
        } else if (filter === 'unanswered' && !isAnswered) {
          item.classList.remove('hidden');
        } else {
          item.classList.add('hidden');
        }
      });
    }
    
    /**
     * Update the counter displays
     */
    function updateCounters() {
      const totalQuestions = examData.questions.length;
      const answeredCount = Object.keys(examData.answers).length;
      const flaggedCount = examData.flagged.length;
      const unansweredCount = totalQuestions - answeredCount;
      
      countAll.textContent = totalQuestions;
      countAnswered.textContent = answeredCount;
      countFlagged.textContent = flaggedCount;
      countUnanswered.textContent = unansweredCount;
    }
    
    /**
     * Toggle the question navigator sidebar
     */
    function toggleQuestionNavigator() {
      questionNavigator.classList.toggle('active');
      updateQuestionGrid();
      updateCounters();
    }
    
    /**
     * Load a question by index
     * @param {number} index - Question index
     */
    function loadQuestion(index) {
      // Validate index
      if (index < 0 || index >= examData.questions.length) {
        console.error('Invalid question index:', index);
        return;
      }
      
      // Update current question index
      examData.currentQuestionIndex = index;
      
      // Get the question
      const question = examData.questions[index];
      
      // Update question number display
      currentQuestionNum.textContent = index + 1;
      
      // Update progress bar
      const progressPercentage = ((index + 1) / examData.questions.length) * 100;
      progressFill.style.width = `${progressPercentage}%`;
      
      // Update navigation buttons
      prevButton.disabled = index === 0;
      
      if (index === examData.questions.length - 1) {
        nextButton.classList.add('hidden');
        submitButton.classList.remove('hidden');
      } else {
        nextButton.classList.remove('hidden');
        submitButton.classList.add('hidden');
      }
      
      // Update flag button
      const isFlagged = examData.flagged.includes(index);
      flagButton.dataset.flagged = isFlagged.toString();
      flagText.textContent = isFlagged ? 'Unflag Question' : 'Flag for Review';
      flagButton.classList.toggle('flagged', isFlagged);
      
      // Start tracking time for this question
      examData.timeSpent[index] = examData.timeSpent[index] || 0;
      examData.currentQuestionStartTime = Date.now();
      
      // Render the question
      renderQuestion(question, index);
      
      // Update question grid
      updateQuestionGrid();
    }
    
    /**
     * Render a question in the container
     * @param {Object} question - Question object
     * @param {number} index - Question index
     */
    function renderQuestion(question, index) {
      // Create question HTML
      const questionHtml = `
        <div class="question-text">
          ${question.text}
        </div>
        <div class="options-container">
          ${renderOptions(question.options, index)}
        </div>
      `;
      
      // Update container
      questionContainer.innerHTML = questionHtml;
      
      // Add event listeners to options
      const optionElements = document.querySelectorAll('.option-item');
      optionElements.forEach(option => {
        option.addEventListener('click', () => {
          // For single-answer questions (default behavior)
          document.querySelectorAll('.option-item').forEach(opt => {
            opt.classList.remove('selected');
          });
          
          option.classList.add('selected');
          
          // Save the answer
          const optionId = option.dataset.optionId;
          examData.answers[index] = optionId;
          
          // Update question grid and counters
          updateQuestionGrid();
          updateCounters();
        });
      });
      
      // If there's a saved answer, select it
      if (examData.answers[index] !== undefined) {
        const savedAnswer = examData.answers[index];
        const savedOption = document.querySelector(`.option-item[data-option-id="${savedAnswer}"]`);
        if (savedOption) {
          savedOption.classList.add('selected');
        }
      }
    }
    
    /**
     * Render question options
     * @param {Array} options - Array of option objects
     * @param {number} questionIndex - Question index
     * @returns {string} HTML for options
     */
    function renderOptions(options, questionIndex) {
      return options.map(option => `
        <div class="option-item" data-option-id="${option.id}">
          <div class="option-marker">${option.id}</div>
          <div class="option-text">${option.text}</div>
        </div>
      `).join('');
    }
    
    /**
     * Go to the previous question
     */
    function goToPreviousQuestion() {
      if (examData.currentQuestionIndex > 0) {
        // Save current question data
        saveCurrentQuestionAnswer();
        saveCurrentQuestionTime();
        
        // Load previous question
        loadQuestion(examData.currentQuestionIndex - 1);
      }
    }
    
    /**
     * Go to the next question
     */
    function goToNextQuestion() {
      if (examData.currentQuestionIndex < examData.questions.length - 1) {
        // Save current question data
        saveCurrentQuestionAnswer();
        saveCurrentQuestionTime();
        
        // Load next question
        loadQuestion(examData.currentQuestionIndex + 1);
      }
    }
    
    /**
     * Toggle the flag status of the current question
     */
    function toggleFlagQuestion() {
      const currentIndex = examData.currentQuestionIndex;
      const isFlagged = examData.flagged.includes(currentIndex);
      
      if (isFlagged) {
        // Remove from flagged array
        examData.flagged = examData.flagged.filter(index => index !== currentIndex);
      } else {
        // Add to flagged array
        examData.flagged.push(currentIndex);
      }
      
      // Update UI
      const newFlagStatus = !isFlagged;
      flagButton.dataset.flagged = newFlagStatus.toString();
      flagText.textContent = newFlagStatus ? 'Unflag Question' : 'Flag for Review';
      flagButton.classList.toggle('flagged', newFlagStatus);
      
      // Update question grid
      updateQuestionGrid();
      updateCounters();
    }
    
    /**
     * Save the current question's answer
     */
    function saveCurrentQuestionAnswer() {
      const currentIndex = examData.currentQuestionIndex;
      const selectedOption = document.querySelector('.option-item.selected');
      
      if (selectedOption) {
        examData.answers[currentIndex] = selectedOption.dataset.optionId;
      }
    }
    
    /**
     * Save the time spent on the current question
     */
    function saveCurrentQuestionTime() {
      const currentIndex = examData.currentQuestionIndex;
      const timeSpent = Math.floor((Date.now() - examData.currentQuestionStartTime) / 1000);
      
      examData.timeSpent[currentIndex] = (examData.timeSpent[currentIndex] || 0) + timeSpent;
      examData.currentQuestionStartTime = Date.now();
    }
    
    /**
     * Save exam progress (for auto-save)
     */
    function saveProgress() {
      // Save current question first
      saveCurrentQuestionAnswer();
      saveCurrentQuestionTime();
      
      // TODO: Implement API call to save progress if needed
      console.log('Progress saved automatically');
    }
    
    /**
     * Show submit confirmation modal
     */
    function showSubmitConfirmation() {
      // Save current answers before showing confirmation
      saveCurrentQuestionAnswer();
      saveCurrentQuestionTime();
      
      // Check if there are unanswered questions
      const answeredCount = Object.keys(examData.answers).length;
      const unansweredQuestionsCount = examData.questions.length - answeredCount;
      
      if (unansweredQuestionsCount > 0) {
        unansweredWarning.classList.remove('hidden');
        unansweredCount.textContent = unansweredQuestionsCount;
      } else {
        unansweredWarning.classList.add('hidden');
      }
      
      submitModal.classList.remove('hidden');
    }
    
    /**
     * Close submit confirmation modal
     */
    function closeSubmitConfirmation() {
      submitModal.classList.add('hidden');
    }
    
    /**
     * Submit the exam
     * @param {boolean} autoSubmit - Whether this is an automatic submission (e.g., timer expired)
     */
    function submitExam(autoSubmit = false) {
      // Stop timer
      clearInterval(timerInterval);
      
      // Save final answers and time
      saveCurrentQuestionAnswer();
      saveCurrentQuestionTime();
      
      // Calculate total time spent
      const totalTimeSpent = examData.timeLimit - timeRemaining;
      
      // Prepare submission data
      const submissionData = {
        attemptId: examData.id,
        answers: examData.answers,
        timeSpentPerQuestion: examData.timeSpent,
        flaggedQuestions: examData.flagged,
        totalTimeSpent: totalTimeSpent,
        autoSubmitted: autoSubmit
      };
      
      // Add proctor events if proctoring was enabled
      if (examData.proctorEnabled) {
        submissionData.proctorEvents = examData.proctorEvents;
      }
      
      // Disable UI elements to prevent further interaction
      disableExamInterface();
      
      // Show loading indicator
      showLoadingOverlay('Submitting your exam...');
      
      // Submit the exam
      fetch('/exams/submit', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(submissionData)
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // Redirect to results page
          window.location.href = `/exams/results/${data.attemptId}`;
        } else {
          // Show error
          hideLoadingOverlay();
          showAlert(data.message || 'Failed to submit exam. Please try again.', 'error');
          
          // Re-enable interface
          enableExamInterface();
          
          // Restart timer if not auto-submitted
          if (!autoSubmit) {
            startTimer();
          }
        }
      })
      .catch(error => {
        console.error('Error submitting exam:', error);
        hideLoadingOverlay();
        showAlert('Network error. Please try again.', 'error');
        
        // Re-enable interface
        enableExamInterface();
        
        // Restart timer if not auto-submitted
        if (!autoSubmit) {
          startTimer();
        }
      });
    }
    
    /**
     * Disable exam interface during submission
     */
    function disableExamInterface() {
      prevButton.disabled = true;
      nextButton.disabled = true;
      submitButton.disabled = true;
      flagButton.disabled = true;
      
      const optionElements = document.querySelectorAll('.option-item');
      optionElements.forEach(option => {
        option.style.pointerEvents = 'none';
      });
      
      document.querySelectorAll('.question-grid-item').forEach(item => {
        item.style.pointerEvents = 'none';
      });
    }
    
    /**
     * Enable exam interface
     */
    function enableExamInterface() {
      prevButton.disabled = examData.currentQuestionIndex === 0;
      nextButton.disabled = false;
      submitButton.disabled = false;
      flagButton.disabled = false;
      
      const optionElements = document.querySelectorAll('.option-item');
      optionElements.forEach(option => {
        option.style.pointerEvents = 'auto';
      });
      
      document.querySelectorAll('.question-grid-item').forEach(item => {
        item.style.pointerEvents = 'auto';
      });
    }
    
    /**
     * Show loading overlay
     * @param {string} message - Loading message
     */
    function showLoadingOverlay(message = 'Loading...') {
      // Create overlay if it doesn't exist
      if (!document.getElementById('loading-overlay')) {
        const overlay = document.createElement('div');
        overlay.id = 'loading-overlay';
        overlay.className = 'loading-overlay';
        overlay.innerHTML = `
          <div class="loading-content">
            <div class="spinner"></div>
            <p id="loading-message" class="loading-message">${message}</p>
          </div>
        `;
        document.body.appendChild(overlay);
      } else {
        document.getElementById('loading-message').textContent = message;
        document.getElementById('loading-overlay').classList.remove('hidden');
      }
    }
    
    /**
     * Hide loading overlay
     */
    function hideLoadingOverlay() {
      const overlay = document.getElementById('loading-overlay');
      if (overlay) {
        overlay.classList.add('hidden');
      }
    }
    
    /**
     * Handle beforeunload event
     * @param {BeforeUnloadEvent} event - The beforeunload event
     */
    function handleBeforeUnload(event) {
      // Prevent accidental navigation away from exam
      event.preventDefault();
      event.returnValue = 'You are in the middle of an exam. Are you sure you want to leave?';
      
      // Log proctor event if proctoring is enabled
      if (examData.proctorEnabled) {
        logProctorEvent('page_exit_attempt', {
          timestamp: new Date().toISOString()
        });
      }
      
      return event.returnValue;
    }
    
 // Client-side Socket.io integration for exam.ejs

// Socket connection variable
let proctorSocket;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
let queuedViolations = [];
let socketInitialized = false;
let webcamMonitoringConfig;

/**
 * Initialize Socket.io connection for proctoring
 */
function initializeProctoring() {
  const webcamContainer = document.getElementById('proctor-webcam-container');
  const webcamElement = document.getElementById('proctor-webcam');
  const statusIndicator = document.getElementById('proctor-status-indicator');
  const statusText = document.getElementById('proctor-status-text');
  
  // Initialize Socket.io connection
  initializeSocket();
  
  // Try to get webcam access
  navigator.mediaDevices.getUserMedia({ video: true, audio: false })
    .then(stream => {
      webcamElement.srcObject = stream;
      
      // Update status and log violation
      updateProctorStatus('active', 'Proctoring Active');
      logViolation('proctor_initialized', {
        webcamActive: true
      });
      
      // Initialize webcam monitoring if proctoring is enabled
      if (examData.proctorEnabled) {
        initializeWebcamMonitoring();
      }
    })
    .catch(error => {
      console.error('Webcam access error:', error);
      
      // Show webcam permission modal
      document.getElementById('webcam-permission-modal').classList.remove('hidden');
      
      // Update status
      updateProctorStatus('error', 'Camera Access Required');
      
      // Log failure
      logViolation('proctor_initialization_failed', {
        error: error.message
      });
      
      // Add retry button event listener
      document.getElementById('retry-webcam').addEventListener('click', () => {
        document.getElementById('webcam-permission-modal').classList.add('hidden');
        initializeProctoring();
      });
    });
    
  // Set up tab visibility monitoring
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      logViolation('tab_switch', {
        visibilityState: 'hidden'
      });
    } else {
      logViolation('tab_switch', {
        visibilityState: 'visible'
      });
    }
  });
  
  // Monitor browser focus
  window.addEventListener('blur', () => {
    logViolation('window_blur');
  });
  
  window.addEventListener('focus', () => {
    logViolation('window_focus');
  });

  // Setup heartbeat interval
  setInterval(() => {
    if (proctorSocket && proctorSocket.connected) {
      proctorSocket.emit('proctor:heartbeat', {
        attemptId: examData.id,
        status: 'active',
        timestamp: new Date()
      });
    }
  }, 30000); // every 30 seconds
}

/**
 * Initialize Socket.io connection
 */
function initializeSocket() {
  // If already initialized, don't do it again
  if (socketInitialized) return;
  socketInitialized = true;

  // Connect to the proctor namespace
  proctorSocket = io('/proctor', {
    reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    timeout: 10000
  });

  // Socket connection events
  proctorSocket.on('connect', () => {
    console.log('Proctor socket connected');
    updateProctorStatus('active', 'Proctoring Active');
    reconnectAttempts = 0;
    
    // Join exam room
    proctorSocket.emit('join_exam', {
      attemptId: examData.id,
      examId: '<%= exam._id %>'
    });
    
    // Process any queued violations
    if (queuedViolations.length > 0) {
      proctorSocket.emit('proctor:violations_batch', queuedViolations);
      queuedViolations = [];
    }
  });

  // Handle join confirmation
  proctorSocket.on('joined_exam', (response) => {
    if (response.success) {
      console.log('Successfully joined exam room');
    } else {
      console.error('Failed to join exam room:', response.message);
    }
  });

  // Handle connection error
  proctorSocket.on('connect_error', (error) => {
    console.error('Proctor socket connection error:', error);
    updateProctorStatus('error', 'Connection Error');
  });

  // Handle disconnection
  proctorSocket.on('disconnect', (reason) => {
    console.warn('Proctor socket disconnected:', reason);
    updateProctorStatus('warning', 'Reconnecting...');
    
    // Log disconnection to local events
    examData.proctorEvents.push({
      type: 'socket_disconnected',
      time: new Date(),
      details: {
        reason
      }
    });
  });

  // Handle reconnection attempts
  proctorSocket.on('reconnect_attempt', (attemptNumber) => {
    reconnectAttempts = attemptNumber;
    updateProctorStatus('warning', `Reconnecting (${attemptNumber}/${MAX_RECONNECT_ATTEMPTS})...`);
  });

  // Handle reconnection failure
  proctorSocket.on('reconnect_failed', () => {
    updateProctorStatus('error', 'Connection Failed');
    showProctorWarning('Proctor connection lost. Your exam session may be reviewed.');
  });

  // Handle batch processing confirmation
  proctorSocket.on('batch_processed', (data) => {
    console.log(`Processed ${data.count} queued violations (${data.successful} successful)`);
  });

  // Handle frame processing response
  proctorSocket.on('frame_processed', (data) => {
    if (data.violations && data.violations.length > 0) {
      handleDetectedViolations(data.violations);
    }
  });

  // Handle warnings from proctors
  proctorSocket.on('proctor_warning', (data) => {
    showProctorWarning(data.message);
  });
  
  // Handle exam termination
  proctorSocket.on('exam_terminated', (data) => {
    showAlert(`Exam terminated: ${data.reason}`, 'error');
    setTimeout(() => {
      submitExam(true, 'proctor_terminated');
    }, 3000);
  });

  // Handle monitoring request from proctor
  proctorSocket.on('monitoring_requested', (data) => {
    // Increase frame rate temporarily
    if (webcamMonitoringConfig) {
      webcamMonitoringConfig.captureInterval = 2000; // More frequent captures
      showAlert('Proctor is reviewing your session', 'info');
    }
  });
  
  // Handle errors
  proctorSocket.on('error', (data) => {
    console.error('Socket error:', data.message);
    showAlert(`Proctor error: ${data.message}`, 'error');
  });
}

/**
 * Update proctor status display
 * @param {string} status - Status type: 'active', 'warning', 'error'
 * @param {string} message - Status message
 */
function updateProctorStatus(status, message) {
  const statusIndicator = document.getElementById('proctor-status-indicator');
  const statusText = document.getElementById('proctor-status-text');
  
  if (statusIndicator && statusText) {
    statusIndicator.className = `status-indicator status-${status}`;
    statusText.textContent = message;
  }
}

/**
 * Log a proctoring violation
 * @param {string} type - Violation type
 * @param {Object} details - Violation details
 */
function logViolation(type, details = {}) {
  const violation = {
    type,
    details: {
      ...details,
      timestamp: new Date().toISOString()
    }
  };
  
  // Add to local events array
  if (!examData.proctorEvents) {
    examData.proctorEvents = [];
  }
  
  examData.proctorEvents.push({
    time: new Date(),
    type,
    details: violation.details
  });
  
  // Send through socket if connected
  if (proctorSocket && proctorSocket.connected) {
    proctorSocket.emit('proctor:violation', {
      attemptId: examData.id,
      type,
      details: violation.details
    });
  } else {
    // Queue violation for when connection is restored
    queuedViolations.push({
      type,
      details: violation.details
    });
    
    // If queue gets too large, use HTTP fallback for oldest violations
    if (queuedViolations.length > 100) {
      const oldestViolation = queuedViolations.shift();
      sendViolationViaHttp(oldestViolation);
    }
  }
}

/**
 * Fallback method to send violations via HTTP when socket is unavailable
 * @param {Object} violation - Violation data
 */
function sendViolationViaHttp(violation) {
  fetch('/exams/proctor/log', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      attemptId: examData.id,
      type: violation.type,
      details: violation.details
    })
  }).catch(error => {
    console.warn('Failed to log violation via HTTP:', error);
  });
}

/**
 * Initialize webcam monitoring for proctoring
 */
function initializeWebcamMonitoring() {
  // Request monitoring configuration from server (using proctorService configuration)
  fetch('/exams/proctor/config')
    .then(response => response.json())
    .then(config => {
      webcamMonitoringConfig = config;
      startWebcamMonitoring(config);
    })
    .catch(error => {
      console.error('Error fetching webcam monitoring config:', error);
      // Use default configuration
      webcamMonitoringConfig = {
        captureInterval: 5000,
        faceDetectionEnabled: true,
        attentionTrackingEnabled: false,
        snapshotsEnabled: false,
        violationThresholds: {
          faceNotVisible: 3,
          multiplesFaces: 1,
          attentionLoss: 5
        }
      };
      startWebcamMonitoring(webcamMonitoringConfig);
    });
}

/**
 * Start webcam monitoring with given configuration
 * @param {Object} config - Monitoring configuration
 */
function startWebcamMonitoring(config) {
  const webcamElement = document.getElementById('proctor-webcam');
  
  // In a real implementation, load TensorFlow.js and face-api.js
  // For this example, we'll simulate face detection
  
  const monitoringInterval = setInterval(() => {
    if (!proctorSocket || !proctorSocket.connected) {
      return; // Skip if not connected
    }
    
    // Simulate frame analysis
    const frameData = simulateFrameAnalysis(webcamElement);
    
    if (proctorSocket.connected) {
      // Send frame for processing on server
      proctorSocket.emit('proctor:process_frame', frameData);
    }
  }, config.captureInterval);
  
  // Cleanup on exam submission
  document.getElementById('confirm-submit').addEventListener('click', () => {
    clearInterval(monitoringInterval);
  });
}

/**
 * Simulate frame analysis (in real implementation, this would use TensorFlow.js)
 * @param {HTMLElement} webcamElement - Webcam video element
 * @returns {Object} - Frame analysis data
 */
function simulateFrameAnalysis(webcamElement) {
  // In a real implementation, this would capture the frame and process it
  // This is a simulation for demonstration purposes
  
  const randomValue = Math.random();
  
  // Simulate face detection
  let faceDetection = {
    facesDetected: 1,
    confidence: 0.95
  };
  
  // Randomly simulate face not visible (10% chance)
  if (randomValue < 0.1) {
    faceDetection = {
      facesDetected: 0,
      confidence: 0.85
    };
  } 
  // Rarely simulate multiple faces (2% chance)
  else if (randomValue > 0.98) {
    faceDetection = {
      facesDetected: 2,
      confidence: 0.9
    };
  }
  
  // Simulate attention tracking
  const attentionTracking = {
    isAttentive: randomValue > 0.15,
    gazeDirection: randomValue > 0.15 ? 'center' : 'outside',
    confidence: 0.8
  };
  
  return {
    timestamp: new Date().toISOString(),
    faceDetection,
    attentionTracking,
    // In real implementation, might include snapshot data if enabled
    // snapshot: webcamElement.captureImage()
  };
}

/**
 * Handle detected violations from frame processing
 * @param {Array} violations - Detected violations
 */
function handleDetectedViolations(violations) {
  // For high severity violations, show warning to user
  const highSeverityViolation = violations.find(v => v.severity === 'high');
  if (highSeverityViolation) {
    let message;
    switch(highSeverityViolation.type) {
      case 'multiple_faces':
        message = 'Multiple people detected. Please ensure you are the only person visible.';
        break;
      case 'face_not_visible':
        message = 'Your face is not visible. Please position yourself properly in front of the camera.';
        break;
      default:
        message = 'A proctoring violation has been detected. Please correct your behavior.';
    }
    showProctorWarning(message);
  }
}

/**
 * Submit the exam with additional context
 * @param {boolean} autoSubmit - Whether this is an automatic submission
 * @param {string} reason - Reason for submission ('timeout', 'proctor_terminated', 'user_submitted')
 */
function submitExam(autoSubmit = false, reason = 'timeout') {
  // Stop timer
  clearInterval(timerInterval);
  
  // Save final answers and time
  saveCurrentQuestionAnswer();
  saveCurrentQuestionTime();
  
  // Calculate total time spent
  const totalTimeSpent = examData.timeLimit - timeRemaining;
  
  // Log submission event
  logViolation('exam_submitted', {
    autoSubmitted: autoSubmit,
    reason,
    totalTimeSpent
  });
  
  // Prepare submission data
  const submissionData = {
    attemptId: examData.id,
    answers: examData.answers,
    timeSpentPerQuestion: examData.timeSpent,
    flaggedQuestions: examData.flagged,
    totalTimeSpent: totalTimeSpent,
    autoSubmitted: autoSubmit,
    submissionReason: reason,
    proctorEvents: examData.proctorEvents // Include proctor events in submission
  };
  
  // Notify socket before disconnecting (if connected)
  if (proctorSocket && proctorSocket.connected) {
    proctorSocket.emit('proctor:violation', {
      attemptId: examData.id,
      type: 'exam_submitted',
      details: {
        autoSubmitted: autoSubmit,
        reason,
        timestamp: new Date().toISOString()
      }
    });
    
    // Give socket time to send final events before disconnecting
    setTimeout(() => {
      proctorSocket.disconnect();
    }, 1000);
  }
  
  // Disable UI elements to prevent further interaction
  disableExamInterface();
  
  // Show loading indicator
  showLoadingOverlay('Submitting your exam...');
  
  // Submit the exam
  fetch('/exams/submit', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(submissionData)
  })
  .then(response => response.json())
  .then(data => {
    if (data.success) {
      // Redirect to results page
      window.location.href = `/exams/results/${data.attemptId}`;
    } else {
      // Show error
      hideLoadingOverlay();
      showAlert(data.message || 'Failed to submit exam. Please try again.', 'error');
      
      // Re-enable interface
      enableExamInterface();
      
      // Restart timer if not auto-submitted
      if (!autoSubmit) {
        startTimer();
      }
    }
  })
  .catch(error => {
    console.error('Error submitting exam:', error);
    hideLoadingOverlay();
    showAlert('Network error. Please try again.', 'error');
    
    // Re-enable interface
    enableExamInterface();
    
    // Restart timer if not auto-submitted
    if (!autoSubmit) {
      startTimer();
    }
  });
}

});
</script>

<!-- Exam Styling -->
<style>
  /* Base layout */
  .exam-container {
    @apply min-h-screen flex flex-col bg-gray-50;
  }
  
  .exam-header {
    @apply bg-white border-b border-gray-200 py-4 shadow-sm z-10 sticky top-0;
  }
  
  .exam-title {
    @apply text-xl font-semibold text-gray-800;
  }
  
  .exam-certification {
    @apply text-sm text-gray-500;
  }
  
  .timer-container {
    @apply flex items-center;
  }
  
  .timer {
    @apply text-lg font-mono font-semibold text-gray-700 px-4 py-2 rounded-md bg-gray-100;
  }
  
  .timer-warning {
    @apply text-yellow-600 bg-yellow-100;
  }
  
  .timer-critical {
    @apply text-red-600 bg-red-100 animate-pulse;
  }
  
  /* Main exam area */
  .exam-main {
    @apply bg-white rounded-lg shadow-md p-6 my-6 relative overflow-hidden;
  }
  
  .progress-container {
    @apply mb-6;
  }
  
  .question-progress {
    @apply text-sm font-medium text-gray-600;
  }
  
  .progress-bar {
    @apply w-full bg-gray-200 rounded-full h-2 mt-2;
  }
  
  .progress-fill {
    @apply bg-blue-600 h-2 rounded-full transition-all duration-300 ease-out;
  }
  
  .review-toggle {
    @apply text-sm text-blue-600 hover:text-blue-800 focus:outline-none;
  }
  
  /* Question styles */
  .question-container {
    @apply mb-8;
  }
  
  .question-text {
    @apply text-lg text-gray-800 mb-6 leading-relaxed;
  }
  
  .options-container {
    @apply space-y-4;
  }
  
  .option-item {
    @apply flex items-start p-4 border border-gray-300 rounded-md cursor-pointer hover:bg-gray-50 transition-colors;
  }
  
  .option-item.selected {
    @apply bg-blue-50 border-blue-500;
  }
  
  .option-marker {
    @apply flex-shrink-0 w-8 h-8 rounded-full bg-gray-100 flex items-center justify-center font-medium text-gray-700 mr-3;
  }
  
  .option-item.selected .option-marker {
    @apply bg-blue-600 text-white;
  }
  
  .option-text {
    @apply text-gray-700 flex-grow pt-1;
  }
  
  .option-item.selected .option-text {
    @apply text-blue-900 font-medium;
  }
  
  /* Navigation controls */
  .navigation-controls {
    @apply flex flex-wrap items-center justify-between mt-8 space-y-4 sm:space-y-0;
  }
  
  .nav-button {
    @apply inline-flex items-center px-4 py-2 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed;
  }
  
  .submit-button {
    @apply inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500;
  }
  
  .flag-button {
    @apply inline-flex items-center px-4 py-2 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500;
  }
  
  .flag-button.flagged {
    @apply bg-yellow-50 text-yellow-700 border-yellow-300;
  }
  
  .flag-button.flagged i {
    @apply text-yellow-500;
  }
  
  /* Question navigator */
  .question-navigator {
    @apply fixed top-0 right-0 h-full w-64 md:w-80 bg-white shadow-lg transform translate-x-full transition-transform duration-300 ease-in-out z-20 flex flex-col overflow-hidden;
  }
  
  .question-navigator.active {
    @apply translate-x-0;
  }
  
  .navigator-header {
    @apply p-4 bg-gray-800 text-white flex justify-between items-center;
  }
  
  .navigator-title {
    @apply text-lg font-medium;
  }
  
  .close-navigator {
    @apply text-gray-300 hover:text-white focus:outline-none;
  }
  
  .navigator-filters {
    @apply flex flex-wrap p-3 bg-gray-100 gap-2;
  }
  
  .filter-button {
    @apply text-xs py-1 px-2 rounded-full border border-gray-300 bg-white text-gray-700 hover:bg-gray-50;
  }
  
  .filter-button.active {
    @apply bg-blue-100 text-blue-800 border-blue-300;
  }
  
  .question-grid {
    @apply p-4 grid grid-cols-5 gap-2 overflow-y-auto flex-grow;
  }
  
  .question-grid-item {
    @apply w-full aspect-square flex items-center justify-center rounded border border-gray-300 bg-white text-sm font-medium text-gray-700 cursor-pointer hover:border-blue-500 hover:text-blue-600;
  }
  
  .question-grid-item.current {
    @apply bg-blue-600 text-white border-blue-600;
  }
  
  .question-grid-item.answered {
    @apply bg-green-100 border-green-300 text-green-800;
  }
  
  .question-grid-item.flagged {
    @apply border-yellow-400;
  }
  
  .question-grid-item.answered.flagged {
    @apply bg-green-100 border-yellow-400;
  }
  
  .question-grid-item.current.flagged {
    @apply bg-blue-600 text-white border-yellow-400 border-2;
  }
  
  .navigator-footer {
    @apply p-4 bg-gray-100 border-t border-gray-200;
  }
  
  .navigator-submit {
    @apply w-full inline-flex justify-center items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500;
  }
  
  /* Proctor webcam */
  .proctor-webcam-container {
    @apply fixed bottom-4 right-4 w-40 h-30 bg-black rounded-md overflow-hidden shadow-lg border-2 border-gray-800 z-10;
  }
  
  .proctor-status {
    @apply absolute bottom-0 left-0 right-0 bg-black bg-opacity-75 text-white text-xs py-1 px-2 flex items-center;
  }
  
  .status-indicator {
    @apply w-2 h-2 rounded-full mr-2;
  }
  
  .status-active {
    @apply bg-green-500;
  }
  
  .status-warning {
    @apply bg-yellow-500;
  }
  
  .status-error {
    @apply bg-red-500;
  }
  
  .status-text {
    @apply text-xs font-medium;
  }
  
  /* Modal styles */
  .modal {
    @apply fixed inset-0 z-50 overflow-y-auto;
  }
  
  .modal-overlay {
    @apply fixed inset-0 bg-black bg-opacity-50;
  }
  
  .modal-container {
    @apply bg-white rounded-lg shadow-xl mx-auto my-8 max-w-lg overflow-hidden relative;
  }
  
  .modal-header {
    @apply px-6 py-4 bg-white border-b border-gray-200 flex justify-between items-center;
  }
  
  .modal-close {
    @apply text-gray-400 hover:text-gray-500;
  }
  
  .modal-body {
    @apply px-6 py-4;
  }
  
  .modal-footer {
    @apply px-6 py-4 bg-gray-50 border-t border-gray-200 flex justify-end space-x-3;
  }
  
  .modal-footer.justify-center {
    @apply justify-center;
  }
  
  /* Button styles */
  .btn {
    @apply inline-flex items-center px-4 py-2 border text-sm font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500;
  }
  
  .btn-primary {
    @apply border-transparent text-white bg-blue-600 hover:bg-blue-700;
  }
  
  .btn-warning {
    @apply border-transparent text-white bg-yellow-600 hover:bg-yellow-700;
  }
  
  .btn-danger {
    @apply border-transparent text-white bg-red-600 hover:bg-red-700;
  }
  
  .btn-outline {
    @apply border-gray-300 text-gray-700 bg-white hover:bg-gray-50;
  }
  
  /* Loading overlay */
  .loading-overlay {
    @apply fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50;
  }
  
  .loading-content {
    @apply bg-white rounded-lg p-6 max-w-sm mx-auto text-center;
  }
  
  .spinner {
    @apply w-12 h-12 border-4 border-blue-200 border-t-blue-600 rounded-full animate-spin mx-auto;
  }
  
  .loading-message {
    @apply mt-4 text-gray-700;
  }
  
  /* Helper classes */
  .hidden {
    @apply hidden;
  }
</style>

<%- include('../layouts/footer') %>